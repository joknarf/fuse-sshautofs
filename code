// ... existing code ...

// cmdNode represents a special node for handling the /cmd/<host>/ps path
type cmdNode struct {
	host string
}

var _ fs.Node = (*cmdNode)(nil)
var _ fs.NodeOpener = (*cmdNode)(nil)
var _ fs.Handle = (*cmdNode)(nil)
var _ fs.HandleReader = (*cmdNode)(nil)

func (c *cmdNode) Attr(ctx context.Context, a *fuse.Attr) error {
	a.Inode = 3
	a.Mode = 0444 // Read-only file
	a.Mtime = time.Now()
	a.Ctime = time.Now()
	a.Uid = uint32(os.Getuid())
	a.Gid = uint32(os.Getgid())
	a.Size = 0 // Size is unknown until read
	return nil
}

func (c *cmdNode) Open(ctx context.Context, req *fuse.OpenRequest, resp *fuse.OpenResponse) (fs.Handle, error) {
	return c, nil
}

func (c *cmdNode) Read(ctx context.Context, req *fuse.ReadRequest, resp *fuse.ReadResponse) error {
	cmd := exec.Command("ssh", c.host, "/bin/ps", "-ef")
	output, err := cmd.Output()
	if err != nil {
		return syscall.EIO
	}
	resp.Data = output[req.Offset:]
	return nil
}

// On lookup, if host dir, ensure sshfs is mounted, then return a symlink node
func (d *autoDir) Lookup(ctx context.Context, name string) (fs.Node, error) {
	hostname := strings.Split(name, "/")[0]
	if strings.HasPrefix(hostname, ".") || hostname == "" {
		return nil, syscall.ENOENT // No such file or directory
	}
	mntTarget := filepath.Join(d.fsys.sshfsRoot, hostname)

	// If not mounted, mount it
	if !isDirMounted(mntTarget) {
		err := os.MkdirAll(mntTarget, 0700)
		if err != nil {
			return nil, syscall.EIO
		}
		sshfsargs := []string{fmt.Sprintf("%s:/", hostname), mntTarget, "-o", d.fsys.sshfsOpts}
		log.Println("Mounting sshfs for host:", hostname, "at", mntTarget, "with sshConfig:", d.fsys.sshConfig)
		if d.fsys.sshConfig != "" {
			sshfsargs = append(sshfsargs, []string{"-F", d.fsys.sshConfig}...)
		}
		sshfsCmd := exec.Command("sshfs", sshfsargs...)
		sshfsCmd.Env = os.Environ()
		if err := sshfsCmd.Run(); err != nil {
			// If mount failed, remove the directory so the symlink does not appear
			log.Println("err:", err)
			os.Remove(mntTarget)
			return nil, syscall.EIO
		}
	}
	// Update last access time for this mount
	updateMountAccess(mntTarget)

	// Check if the path is for the special /cmd/<host>/ps
	if strings.HasPrefix(name, "cmd/") {
		parts := strings.Split(name, "/")
		if len(parts) == 3 && parts[2] == "ps" {
			return &cmdNode{host: parts[1]}, nil
		}
	}

	// Return a symlink node
	return &symlinkNode{
		name:   name,
		target: mntTarget,
	}, nil
}

// ... rest of code ...
